<!doctype html>
<html>
<head>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<style>
    .barRect {
        /* fill: orange; */
        /* fill-opacity: 0.4; */
        stroke: black;
        stroke-opacity: 0.8;
    }

    #yGridG {
        opacity: 0.4;
        stroke-dasharray: 4 8; 
    }

    .backgroundRect {
        fill-opacity: 0.5;
    }

    .targetRect {
        fill: none;
        stroke: red;
        stroke-width: 3px;  
    }

    .legendRect {
        stroke: black;
    }

    .legendText {
        fill-opacity: 0.8;
        font-size: 15px;
    }

    .legendTitle {
        fill-opacity: 0.8;
        font-size: 18px;
    }

    .alert {
        padding: 20px;
        background-color: #f44336; /* Red */
        color: white;
        /* margin-bottom: 15px; */
        position:absolute;
        left: 5px;
        right: 5px;
        top: 5px;
    }

    .closebtn {
        margin-left: 15px;
        color: white;
        font-weight: bold;
        float: right;
        font-size: 22px;
        line-height: 20px;
        cursor: pointer;
        transition: 0.3s;
    }

    #tooltip {
        position: absolute;
        z-index: 10;
        padding: 2px;
        visibility: hidden;
        background: #87CEEBe6;
    }

</style>
<body style="background-color: #A3CCBE">
    <div id="tooltip">
        <text id="service"></text>
        <br>
        <text id="start"></text>
        <br>
        <text id="end"></text>
        <br>
    </div>

    <script>
        /* 
         * FUNCTIONS
         *
         */

        function updateGraph(event, txs) {     
            globalThis.yAxis.y2 = event.transform.rescaleY(globalThis.yAxis.y);
            globalThis.yAxis.self.scale(globalThis.yAxis.y2);
            globalThis.yGridAxis.self.scale(globalThis.yAxis.y2);

            globalThis.yAxis.self.tickValues(globalThis.yAxis.tickValues.slice(...globalThis.yAxis.domainIndex(true)))
            d3.select('#yAxisG').call(globalThis.yAxis.self)

            globalThis.yGridAxis.self.tickValues(globalThis.yGridAxis.gridValues.slice(...globalThis.yAxis.domainIndex()))
            
            let apprxYCnt = getLen(globalThis.yAxis.y2.domain()) / (barHeight+barMargin)
            let gridWidth = width+totalInfoWidth;
            if (apprxYCnt >= 50) {
                gridWidth = 0;
            }
            globalThis.yGridAxis.self.tickSize(gridWidth, 0);
            d3.select('#yGridG').call(globalThis.yGridAxis.self);

            globalThis.xAxis.x2 = event.transform.rescaleX(globalThis.xAxis.x);
            d3.select('#xAxisG').call(globalThis.xAxis.self.scale(globalThis.xAxis.x2)); 

            drawBars(txs)
        }

        function drawInfoCols(root) {
            let sourceInfoRect = root.append('rect')
                .attr('width', infoWidth)
                .classed('sourceInfoRect', true)
            updateSourceInfo(sourceInfoRect)

            let typeInfoRect = root.append('rect')
                .attr('x', infoWidth)
                .attr('width', infoWidth)
                .classed('typeInfoRect', true)
            updateTypeInfo(typeInfoRect)
        }

        function updateInfoCols(update) {
            updateSourceInfo(update.select('.sourceInfoRect'))
            updateTypeInfo(update.select('.typeInfoRect'))
        }

        function updateSourceInfo(update) {
            return update.attr('y', d=>globalThis.yAxis.y2(d.order * (barHeight+barMargin)-barMargin/2))
                .attr('height', globalThis.yAxis.y2(barHeight+barMargin) - globalThis.yAxis.y2(0))
                .attr('fill', d=>sourceColors[d.txSource])
                .attr('stroke', d=>sourceColors[d.txSource]);
        }

        function updateTypeInfo(update) {
            return update.attr('y', d=>globalThis.yAxis.y2(d.order * (barHeight+barMargin)-barMargin/2))
                .attr('height', globalThis.yAxis.y2(barHeight+barMargin) - globalThis.yAxis.y2(0))
                .attr('fill', d=>typeColors[d.txType])
                .attr('stroke', d=>typeColors[d.txType])
        }

        function drawBackgroundRect(root) {
            let newRect = root.append('rect')
                .classed('backgroundRect', true)
            updateBackgroundRect(newRect)
            return newRect
        }

        function updateBackgroundRectX(update) {
            return update.attr('x', globalThis.xAxis.x2(globalThis.xAxis.range.lower))
                .attr('width', globalThis.xAxis.x2(globalThis.xAxis.range.upper)-globalThis.xAxis.x2(globalThis.xAxis.range.lower))
        }

        function updateBackgroundRectY(update) {
            return update.attr('y', (d, i)=>{
                return globalThis.yAxis.y2(d.order * (barHeight+barMargin)-barMargin/2)
            })
                .attr('height', globalThis.yAxis.y2(barHeight+barMargin) - globalThis.yAxis.y2(0))
        }

        function updateBackgroundRect(update) {
            updateBackgroundRectX(update)
            updateBackgroundRectY(update)
            return update.attr('fill', d=>{
                return getBackGroundColor(d)
            })
        }


        function updateBarRectX(update) {
            return update.attr('x', d=>globalThis.xAxis.x2(d.gen))
                .attr('width', d=>globalThis.xAxis.x2(d.fin)-globalThis.xAxis.x2(d.gen))
        }

        function updateBarRectY(update) {
            return update.attr('y', d=> globalThis.yAxis.y2(d.order * (barHeight+barMargin)))
                .attr('height', globalThis.yAxis.y2(barHeight)-globalThis.yAxis.y2(0))
        }

        function updateBarRect(update) {
            updateBarRectX(update)
            updateBarRectY(update)
            updateHoverTooltip(update)
            return update.attr('fill', getBarRectColor)
        }

        function updateHoverTooltip(update) {
            update.on('mouseover', null)
                .on('mousemove', null)
                .on('mouseout', null)

            return update.on('mouseover', function (event, d) {
                let tooltip = d3.select('#tooltip')
                tooltip.select('#service').text(`service time: ${(d.fin-d.gen).toLocaleString()}us`)
                tooltip.select('#start').text(`start: ${d.gen.toLocaleString()}us`)
                tooltip.select('#end').text(`end: ${d.fin.toLocaleString()}us`)
                return tooltip.style("visibility", "visible");
            })
                .on('mousemove', function (e) {
                return d3.select('#tooltip').style("top", (e.pageY-10)+"px").style("left",(e.pageX+10)+"px");
            })
                .on('mouseout', function(e) {
                return d3.select('#tooltip').style("visibility", "hidden");
            })
        }

        function drawBarRect(root) {
            let newRect = root.append('rect')
                .classed('barRect', true)
                .attr("clip-path","url(#clippy)")  

            return updateBarRect(newRect)
        }


        function updateTargetRect(update, txs) {
            if (txs.length > 0 && 'target' in txs[0]) {
                let targetPos = txs.map(d=>d.target).indexOf(1);
                if (targetPos != -1) {
                    return update.attr('y', d=>globalThis.yAxis.y2(txs[targetPos].order * (barHeight+barMargin)-barMargin/2))
                        .attr('width', globalThis.xAxis.x2(globalThis.xAxis.range.upper)+totalInfoWidth)
                        .attr('height', globalThis.yAxis.y2(barHeight+barMargin) - globalThis.yAxis.y2(0))
                        .attr('visibility', 'visible')
                } else {
                    update.attr('visibility', 'none')
                }
            } else {
                update.attr('visibility', 'none')
            }
        }


        function drawBars(txs) {
            let drawingBoard = d3.select('#drawingBoard');
            let graphTop = drawingBoard.select('#graphTop');
            let infoDrawing = drawingBoard.select('#infoDrawing');
            
            let data = txs.slice(...globalThis.yAxis.domainIndex(true))

            graphTop.selectAll('.bars')
                .data(data)
                .join(
                    enter => {
                        let bars = enter.append('g')
                            .classed('bars', true)
                        drawBackgroundRect(bars)
                        drawBarRect(bars)
                    },
                    update => {
                        updateBackgroundRect(update.select('.backgroundRect'))
                        updateBarRect(update.select('.barRect'));
                    },
                    exit => {
                        exit.remove()
                    }
                )

            infoDrawing.selectAll('.infoColG')
                .data(data)
                .join(
                    enter => {
                        let infoColG = enter.append('g')
                            .classed('infoColG', true)
                        drawInfoCols(infoColG)
                    },
                    update => {
                        updateInfoCols(update)
                    },
                    exit => {
                        exit.remove()
                    }
                )

            let infoH = height;
            d3.selectAll('.infoBorder')
                .attr('height', infoH)
            
            let targetRect = drawingBoard.select('.targetRect');
            updateTargetRect(targetRect, txs)
        }

        function getLen(d) {
            return d[1] - d[0];
        }

        let sourceMap = ['USERIO', 'CACHE', 'GC', 'MAPPING']
        let typeMap = ['READ', 'WRITE', 'ERASE']
        let targetMap = ['X', 'O']

        const nonColor = 'chocolate';//'darkgoldenrod'
        const colors = ['lightskyblue', 'lightcoral', 'lightsalmon', 'lightslategray']
        const sourceColors = {
            'USERIO': 'darkgreen', 
            'CACHE': 'darkred', 
            'GC': 'yellow', 
            'MAPPING': 'navy'
        }
        const typeColors = {
            'READ': 'royalblue', 
            'WRITE': 'tomato', 
            'ERASE': 'yellowgreen'
        }
        const targetColor = {
            'X': '#ffffff00', 
            'O': 'red'
        }
        function getBackGroundColor(d) {
            if (d.txSource != 'USERIO') {
                return sourceColors[d.txSource]
            }

            let idx = globalThis.seenOrder[d.requestsId] % colors.length;
            return colors[idx];
        }

        function getBarRectColor(d) {
            if (d.target === 1) {
                return Object.values(targetColor)[1];
            } else {
                return typeColors[d.txType];
            }
        }

        function drawLegend(root, colors, texts, title, className) {
            let arrColors = Object.keys(colors).map(d=>[d, colors[d]])

            let legendRootG = root.append('g')

            legendRootG.append('rect')
                .attr('x', -4)
                .attr('y', -20)
                .attr('width', 86)  
                .attr('height', arrColors.length * 20+20)
                .attr('fill-opacity', 0)
                // .attr('fill', '#A3CCBE')
                .attr('stroke', 'black')

            legendRootG.append('text')
                .text(title)
                .classed(className.title, true)
                .attr('x', 41)
                .attr('dy', '-0.25em')
                .style("text-anchor", "middle")

            
            let legendsG = legendRootG.append('g')
                .selectAll(null)
                .data(arrColors)
                .enter()
                .append('g')

            legendsG.append('rect')
                .attr('y', (d, i)=> i*20)
                .attr('width', 15)
                .attr('height', 15)
                .attr('fill', d=>d[1])
                .classed(className.rect, true)
                
            legendsG.append('text')
                .attr('y', (d, i)=>i*20)
                .attr('x', 15)
                .attr('dy', '0.85em')
                .attr('dx', '0.2em')
                .text(d=>d[0])
                .classed(className.text, true)
        }

        function drawLegends(root) {
            let legendG = root.append('g')
                .attr("transform","translate("+[width + totalInfoWidth + padding.left+10, 50]+")")
                .classed('legends', true)

            let sourceLegendG = legendG.append('g')
                .attr("transform","translate("+[0, 0]+")")
                .classed('sourceLegendG', true)

            let typeLegendG = legendG.append('g')
                .attr("transform","translate("+[0, 100]+")")  
                .classed('typeLegendG', true)

            drawLegend(sourceLegendG, sourceColors, sourceMap, 'Source',
                {rect:'legendRect', text:'legendText', title:'legendTitle'})

            drawLegend(typeLegendG, typeColors, typeMap, 'Type',
                {rect:'legendRect', text:'legendText', title:'legendTitle'})
        }

        function getSeenOrder(txs) {
            const requestsIdOrder = {'CACHE': txs.length, 'GC': txs.length+1, 'MAPPING': txs.length+2};
            let order = 0;
            
            txs.forEach(function(ele, i) {
                if (!(ele.requestsId in requestsIdOrder)) {
                    requestsIdOrder[ele.requestsId] = order;
                    order += 1;
                }
            });

            return requestsIdOrder;
        }

        /*
         * MAIN
         *
         * 
         */
        const margin = {w: 20, h: 80};
        const padding = {top: 20, bottom: 50, left: 80, right: 110};
        const barHeight = 20;
        const barMargin = 4;
        const infoOffset = 0.08;  

        let infoWidth = 30;
        let totalInfoWidth = 2 * infoWidth;

        const width = window.innerWidth - padding.right - padding.left - margin.w - totalInfoWidth;
        const height = window.innerHeight - padding.top - padding.bottom - margin.h;

        let url = new URL(window.location.href)
        let traceId = url.searchParams.get('traceId')
        let target = url.searchParams.get('target')

        const body = d3.select("body");
        const topBar = body.append('div')
            .attr('id', 'topBar')

        const stmtDefault = 'select * from tx order by fin';
        const queryArea = topBar.append('textarea')
                .style('display', 'inline-block')
                .attr('placeholder', stmtDefault)
                .attr('id', 'queryArea')

        const sqlSubmit = topBar.append('button')
            .attr('id', 'sqlSubmit')

        const info = topBar.append('text')
            .attr('id', 'info')
            .text('Total 0 transactions')

        if (!target) {
            const alertDiv = body.append('div')
                .text('Wrong Sql')
                .style('display', 'none')
                .classed('alert', true)

            const xButton = alertDiv.append('span')
                .attr('onclick', "this.parentElement.style.display='none';")
                .html('&times;')
                .classed('closebtn', true)

            sqlSubmit.text('click')
                .style('display', 'inline-block')
                .on('click', onclick)
        } else {
            queryArea.style('display', 'none')
            sqlSubmit.style('display', 'none')
                .on('click', onTargetClick);
            info.style('display', 'none')
        }

        async function onclick() {
            let stmt = d3.select('#queryArea').node().value;

            if (!stmt) {
                stmt = stmtDefault;
            }

            console.log('STMT', stmt)

            let result = await fetch(`${window.location.protocol}//${window.location.host}/tx/${traceId}?sql=${stmt}`)
            let info = d3.select('#info')
            if (result.ok) {
                let data = await result.json()
                info.text(`Total ${data.length} transactions`)
                updateByNewData(data)
            } else {
                let alertDiv = d3.select('.alert')
                    .style('display', 'block')
                setTimeout(()=>alertDiv.style('display', 'none'), 1000);
                info.text(await result.text())
            }
        }

        async function onTargetClick() {
            let stmt = `select tx.*, (tx.id=${target}) as target from tx, (select * from tx where id = ${target}) A where A.gen <= tx.fin and tx.gen <= A.fin order by tx.fin, tx.gen, tx.requestsId, tx.txId`

            console.log('STMT', stmt)

            let url = new URL(window.location.href)

            let fetchUrl = `${window.location.protocol}//${window.location.host}/tx/${traceId}?sql=${stmt}`
            console.log(fetchUrl)
            let result = await fetch(fetchUrl)
            let info = d3.select('#info')
            if (result.ok) {
                let data = await result.json()
                info.text(`Total ${data.length} transactions`)
                updateByNewData(data)
            } else {
                console.log('What')
                console.log('bad', result)
                info.text('Something went wrong')
            }
        }


            
        const mainSvg = body
            .append('svg')
            .attr("width", width + padding.right + padding.left + totalInfoWidth)
            .attr("height", height + padding.top + padding.bottom)
            .attr('id', 'mainSvg')
        
        const plotArea = mainSvg.append("g")
            .attr("transform","translate("+[padding.left,padding.top]+")")  
            .attr('id', 'plotArea')

        const legends = drawLegends(mainSvg)

        const clippingRect = plotArea
            .append("clipPath")
            .attr("id", "clippy")
            .append("rect")
            .attr("width",width+totalInfoWidth)
            .attr("height",height)
            .attr("fill","none")

        const clippingRectJustGraph = plotArea
            .append("clipPath")
            .attr("id", "clippyjustgraph")
            .append("rect")
            .attr("width",width)
            .attr("height",height)
            .attr("fill","none")


        const drawingBoard = plotArea.append('g')
            .attr('id', 'drawingBoard')

        const topG = drawingBoard.append('g')
            .attr('id', 'graphTop')
            .attr("transform", "translate("+[totalInfoWidth, 0]+")")
            .attr("clip-path","url(#clippyjustgraph)")
        
        const infoG = drawingBoard.append('g')
            .attr('id', 'infoG')
            .attr("clip-path","url(#clippy)")

        infoG.append('g')
            .attr('id', 'infoDrawing')

        const infoBorders = infoG.append('g')
            .attr('id', 'infoBorders')

        infoBorders.append('rect')
            .attr('width', infoWidth)
            .classed('infoBorder', true)
            .attr('fill', 'none')
            .attr('stroke', 'black')

        infoBorders.append('rect')
            .attr('x', infoWidth)
            .classed('infoBorder', true)
            .attr('width', infoWidth)
            .attr('fill', 'none')
            .attr('stroke', 'black')

        const targetRect = drawingBoard.append('rect')
            .classed('targetRect', true)
            .attr("clip-path","url(#clippy)")

        const xAxisG = plotArea.append('g')
            .attr("transform","translate("+[totalInfoWidth, 0]+")")
            .attr('id', 'xAxisG')

        const yAxisG = plotArea.append("g")
            .attr('id', 'yAxisG')

        const yGridG = plotArea.append('g')
            .attr('id', 'yGridG')
            .attr("clip-path","url(#clippy)")
            
        const infoAxis = plotArea.append('g')
            .attr('id', 'infoAxis')
            .selectAll('text')
            .data(['S', 'T'])
            .join(enter=>{
                enter.append('text')
                .text(d=>d)
                .attr('x', (d, i)=>i*infoWidth+infoWidth/2)
                .attr('dx', '-0.3em')
                .attr('dy', '-0.15em')
            })


        function updateByNewData(txs) {
            console.log(`Total transactions: ${txs.length}`)
            globalThis.seenOrder = getSeenOrder(txs)
            txs.forEach(function(ele, i) {
                ele.order = i;
            });

            // set xAxis
            {
                let xr = {
                    lower: d3.min(txs, d=>d.gen), 
                    upper: d3.max(txs, d=>d.fin),
                }
                xr.bound = [xr.lower, xr.upper]

                let xAx = {
                    range: xr,
                    x: d3.scaleLinear()
                        .range([0, width])
                        .domain(xr.bound),
                }
                xAx.x2 = xAx.x.copy()
                xAx.self = d3.axisTop(xAx.x2)

                globalThis.xAxis = xAx
            }

            d3.select('#xAxis').call(globalThis.xAxis.self);

            
            // set yAxis
            {
                const maxBars = Math.floor(height / (barHeight+barMargin));

                let yAx = {
                    y: d3.scaleLinear()
                        .range([0, height])
                        .domain([0, maxBars*(barHeight+barMargin)]),
                    tickValues: txs.map((e, i)=> i * (barHeight+barMargin)+barHeight/2),
                    _cacheDomainIndex: null,
                    domainIndex: function (shouldUpdate) {
                        if (shouldUpdate || this._cacheDomainIndex === null) {
                            this._cacheDomainIndex = [
                                Math.max(Math.ceil((this.y2.domain()[0] - barHeight/2)/(barHeight+barMargin)), 0),
                                Math.ceil((this.y2.domain()[1] - barHeight/2)/(barHeight+barMargin))
                            ]
                        }
                        return this._cacheDomainIndex;
                    },
                }
                yAx.y2 = yAx.y.copy()
                yAx.self = d3.axisLeft(yAx.y2)
                    .tickFormat(function(d){
                        order = (d-barHeight/2)/(barHeight+barMargin);

                        if (txs[order].txSource === 'USERIO') {
                            return txs[order].requestsId+'='+txs[order].txId
                        } else {
                            return txs[order].txSource;
                        }                        
                    })
                    .tickValues(yAx.tickValues.slice(...yAx.domainIndex()))

                globalThis.yAxis = yAx
            }
            
            d3.select('#yAxisG').call(globalThis.yAxis.self)

            // draw bars
            drawBars(txs)  
            


            {
                let gridV = txs.map(e=> e.order * (barHeight+barMargin)-barMargin/2);
                let yGridAx = {
                    gridValues: gridV
                }

                yGridAx.self = d3.axisRight(globalThis.yAxis.y2)
                    .tickSize(width+totalInfoWidth, 0)
                    .tickFormat("")
                    .tickValues(yGridAx.gridValues.slice(...globalThis.yAxis.domainIndex()))
                globalThis.yGridAxis = yGridAx
            }

            //draw grids
            d3.select('#yGridG').call(globalThis.yGridAxis.self)

            // handle zoom
            let xDomain = globalThis.xAxis.x.domain();
            let xRange = globalThis.xAxis.x.range();
            let moveRate = (xDomain[1]-xDomain[0]) / (xRange[1]-xRange[0]);
            let minExtent = -xDomain[0] / moveRate;
            const zoom = d3.zoom()
                .translateExtent([[minExtent, 0], [100000, 100000]])
                .on("zoom", function(event) {
                    updateGraph(event, txs);
                })

            let zoomObj = d3.select('#mainSvg').call(zoom);
            zoomObj.call(zoom.transform, d3.zoomIdentity)
        }

        d3.select('#sqlSubmit').node().click()
    </script>
</body>
</html>